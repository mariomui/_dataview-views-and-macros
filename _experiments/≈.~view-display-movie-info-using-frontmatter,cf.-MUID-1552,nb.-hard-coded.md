---
CREATION_DATE: 2023-10-05
DOC_VERSION: v0.0.2
MUID: MUID-1552
PROJECT_PARENT: 
TEMPLATE_VERSION: v1.0.4_blank-template
aliases: 
cssclasses:
  - cards
  - cards-cover
  - cards-2-3
  - table-max
  - dvjs-custom-table-bg
tags:
  - _misc/_wip
share_link: https://share.note.sx/sxgybk8p#1d/Ng/LBOz7oI84DpAC6tP+44Jmkq74n2kRJj4l0bMo
share_updated: 2025-08-31T14:26:23-07:00
SHARED_TO:
  - "[[list-of-people,by-platform,nb.-Netizen-handle,vis-Writer#firefly_reaper|firefly_reaper]]"
  - leo ramirez
  - "[[,aka-charlie-bardeaux,bt.-Wordcamp-netizen]]"
heading: Motion pictures
uri: https://id.loc.gov/authorities/subjects/sh85088084
lcc: PN1993-PN1999
altLabel:
  - Movies
  - Films
  - Cinema
  - Feature films--History and criticism
  - Moving-pictures
broader:
  - "[[Audio-visual materials]]"
  - "[[Mass media]]"
  - "[[Performing arts]]"
narrower:
  - "[[Bureaucracy in motion pictures]]"
  - "[[Slavery in motion pictures]]"
  - "[[National characteristics in motion pictures]]"
  - "[[Demonology in motion pictures]]"
  - "[[Documentary-style films]]"
  - "[[Subways in motion pictures]]"
  - "[[Cold War in motion pictures]]"
---


# -

### About

* [[experiment-symbol,uti.-â‰ˆ,bt.-Noteshippo-title-level-affix,]]
* The way this works is that it gets the adjacent folders of the current context. You won't see shit here. But embedded in a folder, the data is populated with files.
* [ ] Replace the dv.table with custom process since dv rendering has memory leaks âž• 2025-06-23 #_todo/50-backlog--/to-code/upon-codelet
	* ðŸ¤” This seems like it should be a plugin. But with the Base feature on the horizon ... lets wait and see what apis make it easier to create.
- [ ] Allow Folder files to be displayed as well (pref after i get the performance to increase) âž• 2025-06-23 #_todo/to-code/upon-codelet 

## 20-Inlink

> [!abstract]- %%  %% Automated List of Reference Inlinks (v0.0.5)
> * â„¹ Commit/design logs are located in this [[,aka-MUID-150|experiment note]].
> > `= join( map( sort( map( filter(this.file.inlinks, (link) => meta(link).path != this.file.path), (x) => [ split(meta(x).path, "/")[length(split(meta(x).path, "/")) - 1], x ] ) ), (b) => "â€¢ " + choice( length(b[0]) > 28, link( b[1], truncate( regexreplace(b[0], "(-of|of|the|-the|-for|-that|https-|ee)", ""), length( regexreplace(b[0], "(-of|of|the|-the|-for|-that|https-|ee)", "") ) * 0.75 ) ), link(b[1], regexreplace(b[0], "\.md$", "")) ) ), "<br>" )`

# =

**base_filepath-v0.0.9**: `= choice( contains(this.file.folder, this.file.name), link(this.file.path), join(["*",this.file.path,"*"], ""))` doc-`= this.DOC_VERSION` / ids: `= this.MUID`,PP:`= this.PROJECT_PARENT`,alias: *`= this.aliases`*,nb: *`=this.NOTA_BENE`* , authors: *`= this.authors`* / lcsh: `= link(this.heading)`

```dataviewjs

const {default: obs} = this.app.plugins.plugins['templater-obsidian'].templater.current_functions_object.obsidian

const {workspace, vault, metadataCache, fileManager} = this.app;
//*2023-07-22*

workspace.onLayoutReady(bootstrap.bind(this));

// entry file
function bootstrap() {
	(genMain)()
}
// workhorse
async function genMain() {
	const veeFile = metadataCache.getFirstLinkpathDest("+movies.md")
	const veeFolder = getClosestVeeFolder(
		veeFile
	); 

	console.log({veeFolder})

// get the sibling files and folders
	const {
		files, 
		folders
	} = await getFolderContentsByVeeFolder(
		veeFolder
	);

// create  a table structure from these files only [headers, row1, row 2] ,etc.
	const {data} = await processTableFromFiles(
		files.slice(0, -1), 
		veeFolder
	);

	// console.log({files,folders, data})

	if (data) {
		renderMarkdownTable(...data)
	}
}


async function processTableFromFiles(
	files,  // sibling files
	sourceVeeFolder
) {
	// error validataion goes here.
	try {
		return {
			data: await genTableTupleFromFilePaths(
					files, sourceVeeFolder
				),
			error: null
		}
	} catch(err) {
		console.log({err}, "something wrong with processTableFrom Files");
		return {
			data: null,
			err: "genTableTuple error"
		}
	}
} 

const NOT_AVAILABLE = "N/A";

async function genTableTupleFromFilePaths(
	file_paths, 
	sourceVeeFolder
) {
		const basenames = file_paths
			.map(parseBasename)
			.filter((basename) => {
				return basename.endsWith(".md")	
			})
			// .map((basename) => {
			// 	return `!(${basename})[]`;
			// })
		
		// const vfs = file_paths
		// 	.map((file_path) => {
		// 		return getVeeFileByRelativePath(file_path);
		// 	});

		// console.log({vfs})
		 const plotHeader = {
			 field: "plot"
		 }
		const headers = [
			{field: 'year'}, 
			{field: 'director'}, 
			{field: 'title', cb: ((v,fm) => `[[${fm.file_path}|${v}]]`)	}, 
			plotHeader,
			{
				field: 'BANNER',
				cb: (v) => getMarkdownLinkByFilePath(v)
			}
		];
		// first row.
		const header_titles = headers.map(
			(header) => header.field
		);

		// these filepaths cannot be non markdown
		const fms = file_paths.map(getFrontMatterFromFilePath);

		const fmDatums = fms.map((fm) => {
			const column_values = headers.map(({field,cb}) => {
				const value = fm?.[field] ?? "";
				return cb ? cb(value, fm) : value;
			})
			return column_values;
		});

		// subsequent rows;
		const matrixDatums = [];
		for (let i = 0; i < basenames.length; i++) {
			const basename = basenames[i];    
			const fmDatum = fmDatums[i];
			matrixDatums.push(fmDatum)
		}

		return [header_titles, matrixDatums];
}

function getClosestVeeFolder(
	vf, 
	config = {recurseLimit: 20}
) {
	if (vf?.isRoot && vf.isRoot()) return vf;
	
	const closestVeeFolderConfig = {
		...config,
		recurseLimit: config.recurseLimit - 1
	} // no forever things.
	const isFolder = vf.hasOwnProperty("children")
	if (!isFolder) {
		return getClosestVeeFolder(
			vf.parent, 
			closestVeeFolderConfig
		);
	}
	return vf;
}
async function getFolderContentsByVeeFolder(vf) {
	// all utility function shouldn't be validataed. 
	if (vf?.path) {
		return await vault.adapter.list(obs.normalizePath(vf.path));
	}
	return vf;
	// TODO use normalizepath before adding a /
}

function getActiveVeeFile() {
	return workspace.getActiveFile();
}

function getMarkdownLinkByFilePath(file_path) {
	if (!file_path) return "";
	// console.log({file_path})
	return `![](${file_path})`
}
function getWikiLinkByVeeFile(
	vf,
	config = {embed:""}
) {
	const embed_config = config?.embed ?
		 vf.path+"#"+config.embed : 
		 "";

	return fileManager
		.generateMarkdownLink(
			vf, 
			vf.path,
			embed_config,
			vf.basename
		);
}

// # UI the rendering is still using dataview so its super slow. 
function renderMarkdownTable(headers, matrix) {
	dv.table(headers, matrix)
}
function getFrontMatterFromFilePath(file_path) {
	const vf = getVeeFileByRelativePath(file_path);
	try {
		// getFileCache throws. So if you don't handle it at a lower level, it throws up top.
		return {...(metadataCache.getFileCache(vf)?.frontmatter || {}), 
			file_path
		}
	} catch(err) {
		return {err: err};
	}
}

function getVeeFileByRelativePath(
	file_path, 
	relative_path = ""
) {

	const result = metadataCache.getFirstLinkpathDest(
		file_path, relative_path
	);
	// console.log("getVeeFileByRelativePath",{result})
	return result;
}
function parseBasename(file_path) {
	const path = vault.adapter.path.parse(file_path)
	// console.log({path})
	return path.base;
}
```

# ---Transient Local Resources


# ---Transient Doc Log

* @ DOC LOG uti. [[interim--macro-for-inserting-doc-log,nb.-MUID-3120,ver.-v0.0.2]] (ver.-0.0.2)
  * v0.0.1 
    * Fix broken api on the .fileCache (which not thro