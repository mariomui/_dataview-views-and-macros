---
CREATION_DATE: 2025-06-06
MUID: 
PROJECT_PARENT:
  - "[[Ï€-create-codelet-for-replacing-waypoint,uti.-templater-plugin]]"
TEMPLATE_VERSION: v1.0.9_note-refactor-template
tags:
  - _wip
---

# -

## 00-Meta

![[~view-for-local-tasks-using-a-progress-bar,nb.-MUID-698#=|nlk]]

```dataview
task where file.name = this.file.name and !completed
```

```dataview
task where file.name = this.file.name and completed
```

## 10-About

### 11-Reference

![[~view-for-referencing-current-jumpid#=|nlk]]

* â€ 

## 20-Inlink 

# =

**base_filepath-v0.0.2**: *`= this.file.path`* doc-`= this.DOC_VERSION` / ids: `= this.MUID`,`= this.UMID` / lcsh: `= this.heading` / updated on: `= dateformat(this.file.mday, "yyyy-LL-dd")` / file-size: `= round(this.file.size/1024,2)` KB

* [/] #_todo/to-process/upon-codelet/regarding-dataviewjs/regarding-replacement-for-dataview-list  #_todo/42-priority-high--/to-extract/on-a-dataviewjs-codelet Lift and refactor the code below into its own view file.
  * ðŸ¤” If you the folder name by active file, the retrigger somtimes gets the activeFile! the dv refreshes while your cursor is on another page. This really means that this thing Really requires parameterization a
  * ? Is this [[â‰ˆ.~viewfn-for-listing-folder-items]] the extracted code?


```dataviewjs
const {vault, plugins, workspace, fileManager, metadataCache} = this.app;
const {default: obs} = plugins.plugins['templater-obsidian'].templater.current_functions_object.obsidian

const current_file_path = dv.currentFilePath

workspace.onLayoutReady(main.bind(this))

function main() {
  //knobs
  // const vf = workspace.getActiveFile()
  // const folder_path = vf?.parent?.path
  const folder_path = vault
  .getAbstractFileByPath(current_file_path).parent?.path;
  if (!folder_path) return;

  //workhorse
  (async function(ctx, genRenderVfs) {
    // start scope 
    { var _files = [],
          recursedVfs = []; 
      
      try {
        var recursedVfs = await getRecursiveList(folder_path)

        const {files} = await genListByFolderPath(
          folder_path
        );
        console.log({files})
        var _files = _files.concat(files)
      } catch(err) {
        console.error(err);
        return err;
      }
      await genRenderVfs(recursedVfs)
    } // end scope
    
    return;
  })(
    this, 
    genRenderVfs.bind(this),
  );
}


async function genRenderVfs(vfs) {

  for (const vf of vfs) {

    if (vf.hasOwnProperty("children")) {
      const {files} = await genListByFolderPath(vf.path)

      await genListAsDomV2.call(this, vf.name, files)
    }
  }
  return;
}

async function genListAsDomV2(header,datums) {
  await customRenderFiles.call(this,[header,datums])
}

/**
@param val{string|Array}
@param 
@return void
**/
async function customRenderFiles(file_paths) {
  const $frag = document.createDocumentFragment();
  await genRenderValue.call(this,
    file_paths, 
    $frag,
    true,
    "list",
    0,
    new obs.Component()
  )
  return this.container.append($frag)
}
function renderFiles(file_paths) {
 
  const links = file_paths
    .map((file_path) => {
      const vf = vault.getAbstractFileByPath(
        file_path
      );
      /* return metadataCache.fileToLinktext(
        vf, ""
      ); */ 
      // dumb api that generates the shortname from a vfile
      return fileManager.generateMarkdownLink(vf, "")
  })

  dv.list(links);
}
async function genListByFolderPath(folder_path) {
    const list = await vault.adapter
      .list(obs.normalizePath(folder_path))
    return list
}
async function getRecursiveList(path) {
  const vfs = []
  const tfolder = vault.getAbstractFileByPath(path)
  const reclist = await obs.Vault.recurseChildren(tfolder, cb)
  return vfs;
  
  function cb(vf) {
    vfs.push(vf);
  }
}

function getFileNameFromPath(file_path) {
  const {name} = vault.adapter.path.parse(filepath)
  return name;
}



function isArray(candidate) {
  return Object.prototype.toString.call(candidate) === '[object Array]';
}


/**
        child, //value 
        li,  // container
        isExpandList, // alwways expand list really
        "list", // context
         depth + 1 // escape hatch
         
@desc recursive renderer of lists.
**/
async function genRenderValue(
  val,
  container,
  isExpandList, 
  context, 
  depth,
  component
) {
  if (depth > 2) return;
  if (typeof val === "string") {
    await genRenderCompactMarkdown(
      val,
      container,
      "",
      component
    )
    return; 
  }
  
  if (isArray(val)) {
  
    const clss = context === "list" ?
      "dataview-result-list-ul" : 
      "dataview-result-list-root-ul";
    const cls = {
      cls: [
        "dataview",
        "dataview-ul",
        clss
      ]
    }
    let list = container.createEl(
      "ul", 
      {cls}
    );
    for (let child of val) {
      let li = list.createEl("li", manuLiCss());
      await genRenderValue(
        child, //value 
        li,  // container
        isExpandList, // is rest of list
        "list", // context
        depth + 1, // escape hatch
        component
      );
    }
  }
}
/**
@desc LIterally attaches a span literal to the subcontainer right away.
**/
async function genRenderCompactMarkdown(
    markdown, // string,
    container, // HTMLElement,
    sourcePath, // string,
    component // Component
) {
  let subcontainer = container.createSpan();
  await obs.MarkdownRenderer.renderMarkdown(
    markdown, subcontainer, sourcePath, component
  );
  
}

function manuLiCss() {
 return { cls: "dataview-result-list-li" }
}
```

---

# ---Transien